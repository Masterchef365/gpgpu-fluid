#version 450
layout (local_size_x = 32, local_size_y = 32) in;

uniform layout(binding=0) sampler2D read_u;
uniform layout(binding=1) sampler2D read_v;
uniform layout(binding=2, r32f) restrict image2D write_u;
uniform layout(binding=3, r32f) restrict image2D write_v;
uniform layout(location=0) float dt;

float cubic_interp(sampler2D img, vec2 pt) {
    float coeffs[16] = float[16](
        1./6., -1./2., 1./2., -1./6.,
        2./3., 0., -1., 1./2.,
        1./6., 1./2., 1./2., -1./2.,
        0., 0., 0.0, 1./6.
    );
    vec2 fr = fract(pt);
    ivec2 coord = ivec2(pt);
    float col = 0.0;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            vec2 t = vec2(1.);
            vec2 B = vec2(0.);
            for (int k = 0; k < 4; k++) {
                B += t * vec2(coeffs[i*4+k], coeffs[j*4+k]);
                t *= fr;
            }
            float smp = texelFetch(img, coord + ivec2(i-1, j-1), 0).x;
            col += smp * B.x * B.y;
        }
    }
    return col;
}

vec2 gradient(sampler2D img, vec2 pt) {
    float coeffs[16] = float[16](
        1./6., -1./2., 1./2., -1./6.,
        2./3., 0., -1., 1./2.,
        1./6., 1./2., 1./2., -1./2.,
        0., 0., 0.0, 1./6.
    );
    vec2 fr = fract(pt);
    ivec2 coord = ivec2(pt);
    vec2 grad = vec2(0.0);
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            vec2 t = vec2(1.);
            vec2 B = vec2(0.);
            vec2 dB = vec2(0.);
            for (int k = 0; k < 4; k++) {
                vec2 coeff = vec2(coeffs[i*4+k], coeffs[j*4+k]);
                B += t * coeff;
                if (k > 0) dB += pow(fr, vec2(k-1.)) * coeff;
                t *= fr;
            }
            float smp = texelFetch(img, coord + ivec2(i-1, j-1), 0).x;
            grad += smp * (dB.xy * B.yx);
        }
    }
    return grad;
}

float advect_component(sampler2D img, vec2 gid, vec2 u_offset, vec2 v_offset, bool comp) {
    float u = cubic_interp(read_u, gid + u_offset);
    float v = cubic_interp(read_v, gid + v_offset);
    vec2 dr = vec2(u, v) * dt;
    vec2 sample_offset = (comp ? u_offset : v_offset);
    vec2 sample_loc = vec2(gid) - dr + sample_offset;
    float next = cubic_interp(img, sample_loc);
    vec2 grad = gradient(img, sample_loc);
    grad *= vec2(lessThan(abs(dr), vec2(1./2.)));

    next -= dot(grad, dr);

    return next;
}



float interp(sampler2D img, vec2 pt) {
    return cubic_interp(img, pt);
    /*
    if (pt.x < float(textureSize(img, 0).x) / 2.) {
        return cubic_interp(img, pt);
    } else {
        return cubic_interp(img, pt);
    }
    */
}

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = vec2(imageSize(write_u));

    if (dt == 9999.) {
        vec2 vel = vec2(0);

        vec2 uv = gid / size;
        uv = fract(uv * vec2(2., 1.));
        uv = uv * 2. - 1.;
        vel += vec2(0., 8.)
            * float(abs(uv.x) < 0.1)
            * float(abs(uv.y) < 0.1);

        imageStore(write_u, gid, vec4(vel.x, 0,0,0));
        imageStore(write_v, gid, vec4(vel.y, 0,0,0));
        return;
    }

    float next_u = advect_component(read_u, gid, vec2(0), vec2(-0.5,0.5), true);
    float next_v = advect_component(read_v, gid, vec2(0.5,-0.5), vec2(0), false);

    imageStore(write_u, gid, vec4(next_u, 0,0,0));
    imageStore(write_v, gid, vec4(next_v, 0,0,0));
}
