#version 450
layout (local_size_x = 32, local_size_y = 32) in;

uniform layout(binding=0) sampler2D read_u;
uniform layout(binding=1) sampler2D read_v;
uniform layout(binding=2, r32f) restrict image2D write_u;
uniform layout(binding=3, r32f) restrict image2D write_v;
uniform layout(location=0) float dt;

float bilinear(sampler2D img, vec2 pt) {
    vec2 size = imageSize(write_u);
    vec2 tex_coord = (pt + vec2(0.5)) / size;
    return texture(img, tex_coord).x;
}

vec2 gradient(sampler2D img, vec2 pt, vec2 dr, vec2 sample_offset) {
    vec2 size = imageSize(write_u);
    vec4 corners = vec4(
        texture(img, (floor(pt) + vec2(0.5) + vec2(0, 0) + sample_offset) / size).x,
        texture(img, (floor(pt) + vec2(0.5) + vec2(0, 1) + sample_offset) / size).x,
        texture(img, (floor(pt) + vec2(0.5) + vec2(1, 0) + sample_offset) / size).x,
        texture(img, (floor(pt) + vec2(0.5) + vec2(1, 1) + sample_offset) / size).x
    );

    corners = corners.xyzw;

    vec2 f = fract(pt);
    vec2 grad = vec2(f.y - 1., f.x - 1.) * corners.x
              + vec2(-f.y, 1. - f.x) * corners.y
              + vec2(1. - f.y, -f.x) * corners.z
              + vec2(f.y, f.x) * corners.w;
    return grad;// * float(all(lessThan(abs(dr), vec2(0.5))));
}

float advect_component(sampler2D img, vec2 gid, vec2 u_offset, vec2 v_offset, bool comp) {
    float u = bilinear(read_u, gid + u_offset);
    float v = bilinear(read_v, gid + v_offset);
    vec2 dr = vec2(u, v) * dt;
    vec2 sample_offset = (comp ? u_offset : v_offset);
    vec2 sample_loc = vec2(gid) - dr + sample_offset;
    float next = bilinear(img, sample_loc);
    vec2 c = gradient(img, sample_loc, dr, sample_offset);

    float l = length(dr);

    if (l > 0.) {
        // Instability workaround...
        vec2 v = min(l, 0.15) * normalize(dr);
        if (gid.x > imageSize(write_u).x/2) 
            next -= dot(c, v);
    }

    return next;
}

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = vec2(imageSize(write_u));


    if (dt == 9999.) {
        vec2 vel = vec2(0);

        vec2 uv = gid / size;
        uv = fract(uv * vec2(2., 1.));
        uv = uv * 2. - 1.;
        vel += vec2(0., 8.)
            * float(abs(uv.x) < 0.1)
            * float(abs(uv.y) < 0.1);

        imageStore(write_u, gid, vec4(vel.x, 0,0,0));
        imageStore(write_v, gid, vec4(vel.y, 0,0,0));
        return;
    }

    float next_u = advect_component(read_u, gid, vec2(0), vec2(-0.5,0.5), true);
    float next_v = advect_component(read_v, gid, vec2(0.5,-0.5), vec2(0), false);

    imageStore(write_u, gid, vec4(next_u, 0,0,0));
    imageStore(write_v, gid, vec4(next_v, 0,0,0));
}
