#version 450
layout (local_size_x = 32, local_size_y = 32) in;

uniform layout(binding=0) sampler2D read_u;
uniform layout(binding=1) sampler2D read_v;
uniform layout(binding=2, r32f) restrict image2D write_u;
uniform layout(binding=3, r32f) restrict image2D write_v;
uniform layout(location=0) float dt;

float bilinear(sampler2D img, vec2 pt) {
    vec2 size = imageSize(write_u);
    vec2 adjusted = pt + vec2(0.5);
    return texture(img, adjusted / size).x;
}

float cubic_interp(sampler2D img, vec2 pt) {
    float coeffs[16] = float[16](
        1./6., -1./2., 1./2., -1./6.,
        2./3., 0., -1., 1./2.,
        1./6., 1./2., 1./2., -1./2.,
        0., 0., 0.0, 1./6.
    );
    vec2 fr = fract(pt);
    ivec2 coord = ivec2(pt);
    float col = 0.0;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            vec2 t = vec2(1.);
            vec2 B = vec2(0.);
            for (int k = 0; k < 4; k++) {
                B += t * vec2(coeffs[i*4+k], coeffs[j*4+k]);
                t *= fr;
            }
            float smp = texelFetch(img, coord + ivec2(i-1, j-1), 0).x;
            col += smp * B.x * B.y;
        }
    }
    return col;
}

float interp(sampler2D img, vec2 pt) {
    if (pt.x < float(textureSize(img, 0).x) / 2.) {
        return bilinear(img, pt);
    } else {
        return cubic_interp(img, pt);
    }
}

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = vec2(imageSize(write_u));

    if (dt == 9999.) {
        vec2 vel = vec2(0);

        vec2 uv = gid / size;
        uv = fract(uv * vec2(2., 1.));
        uv = uv * 2. - 1.;
        vel += vec2(18., 0.)
            * float(abs(uv.x) < 0.1)
            * float(abs(uv.y) < 0.1);
        if (gid.x * 2. < size.x) vel.x *= -1.;

        imageStore(write_u, gid, vec4(vel.x, 0,0,0));
        imageStore(write_v, gid, vec4(vel.y, 0,0,0));
        return;
    }

    // Advect u
    float u, v;
    u = interp(read_u, gid);
    v = interp(read_v, gid + vec2(-0.5, 0.5));
    vec2 u_sample_loc = vec2(gid) - vec2(u, v) * dt;
    float next_u = interp(read_u, u_sample_loc).x;

    // Advect v
    u = interp(read_u, gid + vec2(0.5, -0.5)).x;
    v = interp(read_v, gid).x;
    vec2 v_sample_loc = vec2(gid) - vec2(u, v) * dt;
    float next_v = interp(read_v, v_sample_loc).x;

    vec2 vel = vec2(next_u, next_v);
    //vel += float(length(uv) < 0.2) * vec2(0.2, 0);

    // Write semi-lagrangian calc
    imageStore(write_u, gid, vec4(vel.x, 0,0,0));
    imageStore(write_v, gid, vec4(vel.y, 0,0,0));
}
