#version 450
layout (local_size_x = 32, local_size_y = 32) in;

uniform layout(binding=0, rgba32f) restrict image2D read_u;
uniform layout(binding=1, rgba32f) restrict image2D read_v;
uniform layout(binding=2, rgba32f) restrict image2D write_u;
uniform layout(binding=3, r32f) restrict image2D write_v;
uniform layout(location=0) uint parity;

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(read_u);

    if (any(greaterThan(gid, size - 1))) {
        return;
    }

    // Read previous state
    ivec2 top_pos = gid;
    ivec2 bottom_pos = gid + ivec2(0, 1);
    ivec2 left_pos = gid;
    ivec2 right_pos = gid + ivec2(1, 0);

    vec4 left = imageLoad(read_u, left_pos);
    vec4 right = imageLoad(read_u, right_pos);
    vec4 top = imageLoad(read_v, top_pos);
    vec4 bottom = imageLoad(read_v, bottom_pos);

    if (left_pos.x == 0) {
        left = vec4(0.);
    }

    if (right_pos.x == size.x - 1) {
        right = vec4(0.);
    }

    if (top_pos.y == 0) {
        top = vec4(0.);
    }

    if (bottom_pos.y == size.y - 1) {
        bottom = vec4(0.);
    }


    // Enforce checkerboard pattern
    if (((gid.x % 2) ^ (gid.y % 2)) == parity) {
        // Calculate divergence
        vec4 dx = right - left;
        vec4 dy = bottom - top;

        vec4 dF = (dx + dy) / 4;

        // Factor must be <2. Forces convergence
        const float OVERSTEP = 1.9;
        dF *= OVERSTEP;

        // Write next state
        imageStore(write_u, left_pos, vec4(left + dF));
        imageStore(write_u, right_pos, vec4(right - dF));
        imageStore(write_v, top_pos, vec4(top + dF));
        imageStore(write_v, bottom_pos, vec4(bottom - dF));
    }
    return;
}
