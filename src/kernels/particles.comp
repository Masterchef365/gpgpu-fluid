#version 450
layout (local_size_x = 32) in;

uniform layout(binding=0) sampler2D read_u;
uniform layout(binding=1) sampler2D read_v;
uniform layout(binding=2, r32f) image2D write_img;
layout(std430, binding=4) buffer Particles {
    vec2 particles[];
};
layout(std430, binding=5) buffer ParticlesWrite {
    vec2 particles_write[];
};
uniform layout(location=0) float dt;

const float PI = 3.141592;
const float TAU = 2. * PI;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 437.5453);
}

void main() {
    int idx = int(gl_GlobalInvocationID.x);
    vec2 last_state = particles[idx];

    bool do_reset = dt == 0.;
    vec2 size = vec2(imageSize(write_img));
    bool out_bounds = last_state.x < 0.
        || last_state.y < 0 
        || last_state.x > size.x 
        || last_state.y > size.y;

    const float RADIUS = 0.3; 
    if (do_reset) {
        float t = TAU * float(idx) / float(particles.length());
        vec2 r = vec2(cos(t), sin(t)) * RADIUS;

        particles[idx] = size * (r + 1. / 2.);
    }

    vec2 uv = particles[idx] / imageSize(write_img);
    float vel_u = texture(read_u, uv).x;
    float vel_v = texture(read_v, uv).x;
    vec2 vel = vec2(vel_u, vel_v);

    vec2 flow_update = vel * dt;

    vec2 pos_update = vec2(0);
    float wanted_displacement = TAU*RADIUS/float(particles.length());
    if (idx > 0 && idx < particles.length() - 1) {
        vec2 l1 = particles[idx - 1] - particles[idx];
        vec2 l2 = particles[idx + 1] - particles[idx];
        vec2 n1 = normalize(l1);
        vec2 n2 = normalize(l2);
        pos_update += n1 * (length(l1) - wanted_displacement);
        pos_update += n2 * (length(l2) - wanted_displacement);
    }

    particles_write[idx] = particles[idx] + flow_update + pos_update * 0.49;
}
