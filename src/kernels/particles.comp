#version 450
layout (local_size_x = 32) in;

uniform layout(binding=0) sampler2D read_u;
uniform layout(binding=1) sampler2D read_v;
uniform layout(binding=2, r32f) image2D write_img;
layout(std430, binding=4) buffer Particles {
    vec4 particles[];
};
uniform layout(location=0) float dt;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    vec2 last_state = particles[idx].xy;

    bool do_reset = dt == 0.;
    vec2 size = vec2(imageSize(write_img));
    bool out_bounds = last_state.x < 0.
        || last_state.y < 0 
        || last_state.x > size.x 
        || last_state.y > size.y;

    if (do_reset) {
        float rx = rand(last_state + vec2(2344., idx) / 1000);
        float ry = rand(last_state + vec2(1244., idx) / 1000);

        vec2 r = vec2(rx, ry);

        vec2 j = vec2(
            rand(vec2(idx)),
            rand(vec2(idx+8))
        ) * 2. - 1.;

        if (out_bounds) {
            r = particles[uint(particles.length() * rx)].xy;
        }
        /*
        if (!out_bounds) {
        */

        /*
            vec2 k = size/30.;
            if (rand(vec2(idx)) < 0.5) {
                r.y = floor(r.y * k.y) / k.y;
            } else {
                r.x = floor(r.x * k.x) / k.x;
            }
        */
            r += j/750.;
        //}


        vec2 pos = r * size;
        float time = (r.x + r.y) * 30.;
        particles[idx] = vec4(pos, r);
    }

    vec2 uv = particles[idx].xy / imageSize(write_img);
    float vel_u = texture(read_u, uv).x;
    float vel_v = texture(read_v, uv).x;
    vec2 vel = vec2(vel_u, vel_v);

    particles[idx].xy += vel * dt;
    //particles[idx].w += dt;
}
